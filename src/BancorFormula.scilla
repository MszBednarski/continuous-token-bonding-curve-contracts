scilla_version 0

import IntUtils ListUtils
library BancorFormula

let MIN_PRECISION = Uint256 32
let MAX_PRECISION = Uint256 127
let MAX_WEIGHT = Uint256 1000000
let FIXED_1 = Uint256 170141183460469231731687303715884105728
let FIXED_2 = Uint256 340282366920938463463374607431768211456
let MAX_NUM = Uint256 680564733841876926926749214863536422912
let OPT_LOG_MAX_VAL = Uint256 462491687273110168575455517921668397539
let OPT_EXP_MAX_VAL = Uint256 2722258935367507707706996859454145691648
let LN2_NUMERATOR = Uint256 5275695611177340518812009417546793976
let LN2_DENOMINATOR = Uint256 7611219895485218073587121647846406784
let zero_uint128 = Uint128 0
let zero_uint256 = Uint256 0
let two_uint256 = Uint256 0

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

type Error =
| CodeInputIsZero
| CodeInputNotInBounds

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeInputIsZero => Int32 -1
      | CodeInputNotInBounds => Int32 -2
      end
    in
    { _exception : "Error"; code : result_code }

(* implements (x * y) / z *)
let muldiv: Uint256 -> Uint256 -> Uint256 -> Uint256 =
    fun(x: Uint256) => fun(y: Uint256) => fun(z: Uint256) =>
    let xy = builtin mul x y in
    builtin div xy z

(* implements ((x * (k - b)) / z ) + r *)
let submuldivadd: Uint256 -> Uint256 -> Uint256 -> Uint256 -> Uint256 =
    fun(x: Uint256) => fun(k: Uint256) => fun(b: Uint256) => fun(z: Uint256) => fun(r: Uint256) =>
    let k_sub_b = builtin sub k b in
    let tmp = muldiv x k_sub_b z in
    builtin add tmp r

(* used to panic, divides by zero! *)
let panic: Uint256 -> Uint256 =
    fun(numerator: Uint256) =>
    builtin div zero_uint256 zero_uint256

let uint128_to_uint256: Uint128 -> Uint256 =
    fun (x: Uint128) =>
    let ox256 = builtin to_uint256 x in
    match ox256 with
    | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        panic zero_uint256
    | Some x256 => x256
    end
let uint256_to_uint128: Uint256 -> Uint128 =
    fun (x: Uint256) =>
    let ores128 = builtin to_uint128 x in
    match ores128 with
    | None =>
        (* this must never happen, panic by dividing by zero *)
        panic zero_uint256
    | Some res128 =>
        res128
    end

(*
    Return log(x / FIXED_1) * FIXED_1
    Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1
    Detailed description:
    - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2
    - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent
    - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1
    - The natural logarithm of the input is calculated by summing up the intermediate results above
    - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)
*)
let optimalLog: Uint256 -> Uint256 =
    fun(x: Uint256) =>
    type ThresholdAndToAdd = | ThresholdAndToAdd of Uint256 Uint256 in
    type XAndRes = | XAndRes of Uint256 Uint256 in
    (* build the list for foldl *)
    (* Auto-generated via # Generate optimal log part 1 .ipynb *)
        let threshold_val0 = Uint256 280515388193368458015406427511040113880 in
        let to_add0 = Uint256 85070591730234615865843651857942052864 in
    let threshold0 = ThresholdAndToAdd threshold_val0 to_add0 in (*  add 1 / 2^1 *)
        let threshold_val1 = Uint256 218465603988574474844591417643679820199 in
        let to_add1 = Uint256 42535295865117307932921825928971026432 in
    let threshold1 = ThresholdAndToAdd threshold_val1 to_add1 in (*  add 1 / 2^2 *)
        let threshold_val2 = Uint256 192795218841189805222451540510555621025 in
        let to_add2 = Uint256 21267647932558653966460912964485513216 in
    let threshold2 = ThresholdAndToAdd threshold_val2 to_add2 in (*  add 1 / 2^3 *)
        let threshold_val3 = Uint256 181114347027396448854165353426875372712 in
        let to_add3 = Uint256 10633823966279326983230456482242756608 in
    let threshold3 = ThresholdAndToAdd threshold_val3 to_add3 in (*  add 1 / 2^4 *)
        let threshold_val4 = Uint256 175542044379434494067323265867529472979 in
        let to_add4 = Uint256 5316911983139663491615228241121378304 in
    let threshold4 = ThresholdAndToAdd threshold_val4 to_add4 in (*  add 1 / 2^5 *)
        let threshold_val5 = Uint256 172820517236198538127967385733353125282 in
        let to_add5 = Uint256 2658455991569831745807614120560689152 in
    let threshold5 = ThresholdAndToAdd threshold_val5 to_add5 in (*  add 1 / 2^6 *)
        let threshold_val6 = Uint256 171475617301169790829459146906809945753 in
        let to_add6 = Uint256 1329227995784915872903807060280344576 in
    let threshold6 = ThresholdAndToAdd threshold_val6 to_add6 in (*  add 1 / 2^7 *)
        let threshold_val7 = Uint256 170807097224429000759274174605493073715 in
        let to_add7 = Uint256 664613997892457936451903530140172288 in
    let threshold7 = ThresholdAndToAdd threshold_val7 to_add7 in (*  add 1 / 2^8 *)

    let nil = Nil {ThresholdAndToAdd} in
    let l0 = Cons {ThresholdAndToAdd} threshold0 nil in
    let l1 = Cons {ThresholdAndToAdd} threshold1 l0 in
    let l2 = Cons {ThresholdAndToAdd} threshold2 l1 in
    let l3 = Cons {ThresholdAndToAdd} threshold3 l2 in
    let l4 = Cons {ThresholdAndToAdd} threshold4 l3 in
    let l5 = Cons {ThresholdAndToAdd} threshold5 l4 in
    let l6 = Cons {ThresholdAndToAdd} threshold6 l5 in
    let l7 = Cons {ThresholdAndToAdd} threshold7 l6 in

    let folder_stage_1 = fun(x_and_res: XAndRes) => fun(threshold_and_to_add: ThresholdAndToAdd) =>
        match x_and_res with 
        | XAndRes local_x local_res =>
            match threshold_and_to_add with
            | ThresholdAndToAdd threshold to_add =>
                let x_ge = uint256_ge local_x threshold in
                match x_ge with
                | True =>
                    let newRes = builtin add local_res to_add in
                    let newX = muldiv local_x FIXED_1 threshold in
                    XAndRes newX newRes
                | False => XAndRes local_x local_res
            end
        end

    let fold_stage_1 = @list_foldl ThresholdAndToAdd XAndRes in

    let xAndResInit = XAndRes x zero_uint256 in

    let stage_1_x_and_res = fold_stage_1 folder_stage_1 xAndResInit l7 in
    match stage_1_x_and_res with
    | XAndRes x_1 local_res_0 =>
        (* now taylor series *)
        (* Auto-generated via # Generate optimal log part 2 .ipynb *)
        let y = builtin sub x_1 FIXED_1 in
        let z0 = y in
        let w = muldiv y y FIXED_1 in

        (* ((x * (k - b)) / z ) + r *)
            let numerator1 = Uint256 340282366920938463463374607431768211456 in
            let denominator1 = Uint256 340282366920938463463374607431768211456 in
        let local_res_1 = submuldivadd z0 numerator1 y denominator1 local_res_0 in let z1 = muldiv z0 w FIXED_1 in (* add y^01 / 01 - y^02 / 02 *)
            let numerator2 = Uint256 226854911280625642308916404954512140970 in
            let denominator2 = Uint256 680564733841876926926749214863536422912 in
        let local_res_2 = submuldivadd z1 numerator2 y denominator2 local_res_1 in let z2 = muldiv z1 w FIXED_1 in (* add y^03 / 03 - y^04 / 04 *)
            let numerator3 = Uint256 204169420152563078078024764459060926873 in
            let denominator3 = Uint256 1020847100762815390390123822295304634368 in
        let local_res_3 = submuldivadd z2 numerator3 y denominator3 local_res_2 in let z3 = muldiv z2 w FIXED_1 in (* add y^05 / 05 - y^06 / 06 *)
            let numerator4 = Uint256 194447066811964836264785489961010406546 in
            let denominator4 = Uint256 1361129467683753853853498429727072845824 in
        let local_res_4 = submuldivadd z3 numerator4 y denominator4 local_res_3 in let z4 = muldiv z3 w FIXED_1 in (* add y^07 / 07 - y^08 / 08 *)
            let numerator5 = Uint256 189045759400521368590763670795426784142 in
            let denominator5 = Uint256 1701411834604692317316873037158841057280 in
        let local_res_5 = submuldivadd z4 numerator5 y denominator5 local_res_4 in let z5 = muldiv z4 w FIXED_1 in (* add y^09 / 09 - y^10 / 10 *)
            let numerator6 = Uint256 185608563775057343707295240417328115339 in
            let denominator6 = Uint256 2041694201525630780780247644590609268736 in
        let local_res_6 = submuldivadd z5 numerator6 y denominator6 local_res_5 in let z6 = muldiv z5 w FIXED_1 in (* add y^11 / 11 - y^12 / 12 *)
            let numerator7 = Uint256 183228966803582249557201711694029036937 in
            let denominator7 = Uint256 2381976568446569244243622252022377480192 in
        let local_res_7 = submuldivadd z6 numerator7 y denominator7 local_res_6 in let z7 = muldiv z6 w FIXED_1 in (* add y^13 / 13 - y^14 / 14 *)
            let numerator8 = Uint256 181483929024500513847133123963609712776 in
            let denominator8 = Uint256 2722258935367507707706996859454145691648 in
        let local_res_8 = submuldivadd z7 numerator8 y denominator8 local_res_7 in (* add y^15 / 15 - y^16 / 16 *)
        (* done! *)
        local_res_8
    end

(*
    Compute the largest integer smaller than or equal to the binary logarithm of the input.
*)
let floorLog2: Uint256 -> Uint256 =
    fun(_n: Uint256) =>
    let nil = Nil {ThresholdAndToAdd} in
    let i_temp1 = Uint256 1 in let l1 = Cons {Uint256} i_temp1 nil in let i_temp2 = Uint256 2 in let l2 = Cons {Uint256} i_temp2 l1 in let i_temp3 = Uint256 4 in let l3 = Cons {Uint256} i_temp3 l2 in let i_temp4 = Uint256 8 in let l4 = Cons {Uint256} i_temp4 l3 in let i_temp5 = Uint256 16 in let l5 = Cons {Uint256} i_temp5 l4 in let i_temp6 = Uint256 32 in let l6 = Cons {Uint256} i_temp6 l5 in let i_temp7 = Uint256 64 in let l7 = Cons {Uint256} i_temp7 l6 in let i_temp8 = Uint256 128 in let l8 = Cons {Uint256} i_temp8 l7 in
    type NAndRes = | NAndRes of Uint256 Uint256 in
    let uint256_256 = Uint256 256 in
    let _n_lt_256 = uint256_lt _n uint256_256 in
    let init = NAndRes _n zero_uint256 in
    let result_n_and_res = match _n_lt_256 with
    | True =>
        let folder: NAndRes -> Uint256 -> Option NAndRes =
            fun(local_n_and_res: NAndRes) => fun(index: Uint256) =>
                match local_n_and_res with
                | NAndRes local_n local_res =>
                    let one = Uint256 1 in
                    let local_n_gt_one = uint256_gt local_n one in
                    match local_n_gt_one with
                    | False => None
                    | True =>
                        let new_n = builtin div local_n two_uint256 in
                        let new_res builtin add local_res one in
                        let tmp = NAndRes new_n new_res in
                        Some {NAndRes} tmp
                    end
                end
        let fold = @list_foldl_while Uint256 NAndRes in
        fold folder init l8
    | False =>
        let folder: NAndRes -> Uint256 -> NAndRes =
            fun(local_n_and_res: NAndRes) => fun(bits: Uint256) =>
                match local_n_and_res with
                | NAndRes local_n local_res =>
                    let two_pow_bits = builtin pow two_uint256 bits in
                    let n_ge_two_pow_bits = uint256_ge local_n two_pow_bits in
                    match n_ge_two_pow_bits with
                    | True =>
                        (* divide by biggest component *)
                        let new_n = builtin div local_n two_pow_bits in
                        (* add exponent *)
                        let new_res = builtin add local_res bits in
                        NAndRes new_n new_res
                    | False => NAndRes local_n local_res
                    end
                end
        let fold = @list_foldl Uint256 NAndRes in
        fold folder init l8
    end in
    match result_n_and_res with
    | NAndRes result_n result_res => result_res
    end

(*
    Compute log(x / FIXED_1) * FIXED_1.
    This functions assumes that "x >= FIXED_1", because the output would be negative otherwise.
*)
let generalLog: Uint256 -> Uint256 =
    fun(x: Uint256) =>
    (* If x >= 2, then we compute the integer part of log2(x), which is larger than 0. *)
    let x_ge_two = uint256_ge x FIXED_2 in
    type ResAndX = | ResAndX of Uint256 Uint256 in
    let res_and_x = match x_ge_two with
        | True => 
            let x_div_fixed_1 = builtin div x FIXED_1 in
            let count = floorLog2 x_div_fixed_1 in
            let two_pow_count = builtin pow two_uint256 count in
            let xshifted = builtin div x two_pow_count in (* now x < 2 *)
            let newRes = builtin mul count FIXED_1 in
            ResAndX newRes xshifted
        | False => ResAndX zero_uint256 x
        end in
    match res_and_x with
    | ResAndX res1 x1 =>
        (* If x > 1, then we compute the fraction part of log2(x), which is larger than 0. *)
        let x1_gt_fixed_1 = uint256_gt x1 FIXED_1 in
        match x1_gt_fixed_1 with
        | True =>
            (* autogenerated by generate floorLog2 loop *)
                let nil = Nil {ThresholdAndToAdd} in
                let i_temp1 = Uint256 1 in let l1 = Cons {Uint256} i_temp1 nil in let i_temp2 = Uint256 2 in let l2 = Cons {Uint256} i_temp2 l1 in let i_temp3 = Uint256 3 in let l3 = Cons {Uint256} i_temp3 l2 in let i_temp4 = Uint256 4 in let l4 = Cons {Uint256} i_temp4 l3 in let i_temp5 = Uint256 5 in let l5 = Cons {Uint256} i_temp5 l4 in let i_temp6 = Uint256 6 in let l6 = Cons {Uint256} i_temp6 l5 in let i_temp7 = Uint256 7 in let l7 = Cons {Uint256} i_temp7 l6 in let i_temp8 = Uint256 8 in let l8 = Cons {Uint256} i_temp8 l7 in let i_temp9 = Uint256 9 in let l9 = Cons {Uint256} i_temp9 l8 in let i_temp10 = Uint256 10 in let l10 = Cons {Uint256} i_temp10 l9 in let i_temp11 = Uint256 11 in let l11 = Cons {Uint256} i_temp11 l10 in let i_temp12 = Uint256 12 in let l12 = Cons {Uint256} i_temp12 l11 in let i_temp13 = Uint256 13 in let l13 = Cons {Uint256} i_temp13 l12 in let i_temp14 = Uint256 14 in let l14 = Cons {Uint256} i_temp14 l13 in let i_temp15 = Uint256 15 in let l15 = Cons {Uint256} i_temp15 l14 in let i_temp16 = Uint256 16 in let l16 = Cons {Uint256} i_temp16 l15 in let i_temp17 = Uint256 17 in let l17 = Cons {Uint256} i_temp17 l16 in let i_temp18 = Uint256 18 in let l18 = Cons {Uint256} i_temp18 l17 in let i_temp19 = Uint256 19 in let l19 = Cons {Uint256} i_temp19 l18 in let i_temp20 = Uint256 20 in let l20 = Cons {Uint256} i_temp20 l19 in let i_temp21 = Uint256 21 in let l21 = Cons {Uint256} i_temp21 l20 in let i_temp22 = Uint256 22 in let l22 = Cons {Uint256} i_temp22 l21 in
                let i_temp23 = Uint256 23 in let l23 = Cons {Uint256} i_temp23 l22 in let i_temp24 = Uint256 24 in let l24 = Cons {Uint256} i_temp24 l23 in let i_temp25 = Uint256 25 in let l25 = Cons {Uint256} i_temp25 l24 in let i_temp26 = Uint256 26 in let l26 = Cons {Uint256} i_temp26 l25 in let i_temp27 = Uint256 27 in let l27 = Cons {Uint256} i_temp27 l26 in let i_temp28 = Uint256 28 in let l28 = Cons {Uint256} i_temp28 l27 in let i_temp29 = Uint256 29 in let l29 = Cons {Uint256} i_temp29 l28 in let i_temp30 = Uint256 30 in let l30 = Cons {Uint256} i_temp30 l29 in let i_temp31 = Uint256 31 in let l31 = Cons {Uint256} i_temp31 l30 in let i_temp32 = Uint256 32 in let l32 = Cons {Uint256} i_temp32 l31 in let i_temp33 = Uint256 33 in let l33 = Cons {Uint256} i_temp33 l32 in let i_temp34 = Uint256 34 in let l34 = Cons {Uint256} i_temp34 l33 in let i_temp35 = Uint256 35 in let l35 = Cons {Uint256} i_temp35 l34 in let i_temp36 = Uint256 36 in let l36 = Cons {Uint256} i_temp36 l35 in let i_temp37 = Uint256 37 in let l37 = Cons {Uint256} i_temp37 l36 in let i_temp38 = Uint256 38 in let l38 = Cons {Uint256} i_temp38 l37 in let i_temp39 = Uint256 39 in let l39 = Cons {Uint256} i_temp39 l38 in let i_temp40 = Uint256 40 in let l40 = Cons {Uint256} i_temp40 l39 in let i_temp41 = Uint256 41 in let l41 = Cons {Uint256} i_temp41 l40 in let i_temp42 = Uint256 42 in let l42 = Cons {Uint256} i_temp42 l41 in let i_temp43 = Uint256 43 in let l43 = Cons {Uint256} i_temp43 l42 in
                let i_temp44 = Uint256 44 in let l44 = Cons {Uint256} i_temp44 l43 in let i_temp45 = Uint256 45 in let l45 = Cons {Uint256} i_temp45 l44 in let i_temp46 = Uint256 46 in let l46 = Cons {Uint256} i_temp46 l45 in let i_temp47 = Uint256 47 in let l47 = Cons {Uint256} i_temp47 l46 in let i_temp48 = Uint256 48 in let l48 = Cons {Uint256} i_temp48 l47 in let i_temp49 = Uint256 49 in let l49 = Cons {Uint256} i_temp49 l48 in let i_temp50 = Uint256 50 in let l50 = Cons {Uint256} i_temp50 l49 in let i_temp51 = Uint256 51 in let l51 = Cons {Uint256} i_temp51 l50 in let i_temp52 = Uint256 52 in let l52 = Cons {Uint256} i_temp52 l51 in let i_temp53 = Uint256 53 in let l53 = Cons {Uint256} i_temp53 l52 in let i_temp54 = Uint256 54 in let l54 = Cons {Uint256} i_temp54 l53 in let i_temp55 = Uint256 55 in let l55 = Cons {Uint256} i_temp55 l54 in let i_temp56 = Uint256 56 in let l56 = Cons {Uint256} i_temp56 l55 in let i_temp57 = Uint256 57 in let l57 = Cons {Uint256} i_temp57 l56 in let i_temp58 = Uint256 58 in let l58 = Cons {Uint256} i_temp58 l57 in let i_temp59 = Uint256 59 in let l59 = Cons {Uint256} i_temp59 l58 in let i_temp60 = Uint256 60 in let l60 = Cons {Uint256} i_temp60 l59 in let i_temp61 = Uint256 61 in let l61 = Cons {Uint256} i_temp61 l60 in let i_temp62 = Uint256 62 in let l62 = Cons {Uint256} i_temp62 l61 in let i_temp63 = Uint256 63 in let l63 = Cons {Uint256} i_temp63 l62 in let i_temp64 = Uint256 64 in let l64 = Cons {Uint256} i_temp64 l63 in
                let i_temp65 = Uint256 65 in let l65 = Cons {Uint256} i_temp65 l64 in let i_temp66 = Uint256 66 in let l66 = Cons {Uint256} i_temp66 l65 in let i_temp67 = Uint256 67 in let l67 = Cons {Uint256} i_temp67 l66 in let i_temp68 = Uint256 68 in let l68 = Cons {Uint256} i_temp68 l67 in let i_temp69 = Uint256 69 in let l69 = Cons {Uint256} i_temp69 l68 in let i_temp70 = Uint256 70 in let l70 = Cons {Uint256} i_temp70 l69 in let i_temp71 = Uint256 71 in let l71 = Cons {Uint256} i_temp71 l70 in let i_temp72 = Uint256 72 in let l72 = Cons {Uint256} i_temp72 l71 in let i_temp73 = Uint256 73 in let l73 = Cons {Uint256} i_temp73 l72 in let i_temp74 = Uint256 74 in let l74 = Cons {Uint256} i_temp74 l73 in let i_temp75 = Uint256 75 in let l75 = Cons {Uint256} i_temp75 l74 in let i_temp76 = Uint256 76 in let l76 = Cons {Uint256} i_temp76 l75 in let i_temp77 = Uint256 77 in let l77 = Cons {Uint256} i_temp77 l76 in let i_temp78 = Uint256 78 in let l78 = Cons {Uint256} i_temp78 l77 in let i_temp79 = Uint256 79 in let l79 = Cons {Uint256} i_temp79 l78 in let i_temp80 = Uint256 80 in let l80 = Cons {Uint256} i_temp80 l79 in let i_temp81 = Uint256 81 in let l81 = Cons {Uint256} i_temp81 l80 in let i_temp82 = Uint256 82 in let l82 = Cons {Uint256} i_temp82 l81 in let i_temp83 = Uint256 83 in let l83 = Cons {Uint256} i_temp83 l82 in let i_temp84 = Uint256 84 in let l84 = Cons {Uint256} i_temp84 l83 in let i_temp85 = Uint256 85 in let l85 = Cons {Uint256} i_temp85 l84 in 
                let i_temp86 = Uint256 86 in let l86 = Cons {Uint256} i_temp86 l85 in let i_temp87 = Uint256 87 in let l87 = Cons {Uint256} i_temp87 l86 in let i_temp88 = Uint256 88 in let l88 = Cons {Uint256} i_temp88 l87 in let i_temp89 = Uint256 89 in let l89 = Cons {Uint256} i_temp89 l88 in let i_temp90 = Uint256 90 in let l90 = Cons {Uint256} i_temp90 l89 in let i_temp91 = Uint256 91 in let l91 = Cons {Uint256} i_temp91 l90 in let i_temp92 = Uint256 92 in let l92 = Cons {Uint256} i_temp92 l91 in let i_temp93 = Uint256 93 in let l93 = Cons {Uint256} i_temp93 l92 in let i_temp94 = Uint256 94 in let l94 = Cons {Uint256} i_temp94 l93 in let i_temp95 = Uint256 95 in let l95 = Cons {Uint256} i_temp95 l94 in let i_temp96 = Uint256 96 in let l96 = Cons {Uint256} i_temp96 l95 in let i_temp97 = Uint256 97 in let l97 = Cons {Uint256} i_temp97 l96 in let i_temp98 = Uint256 98 in let l98 = Cons {Uint256} i_temp98 l97 in let i_temp99 = Uint256 99 in let l99 = Cons {Uint256} i_temp99 l98 in let i_temp100 = Uint256 100 in let l100 = Cons {Uint256} i_temp100 l99 in let i_temp101 = Uint256 101 in let l101 = Cons {Uint256} i_temp101 l100 in let i_temp102 = Uint256 102 in let l102 = Cons {Uint256} i_temp102 l101 in let i_temp103 = Uint256 103 in let l103 = Cons {Uint256} i_temp103 l102 in let i_temp104 = Uint256 104 in let l104 = Cons {Uint256} i_temp104 l103 in let i_temp105 = Uint256 105 in let l105 = Cons {Uint256} i_temp105 l104 in
                let i_temp106 = Uint256 106 in let l106 = Cons {Uint256} i_temp106 l105 in let i_temp107 = Uint256 107 in let l107 = Cons {Uint256} i_temp107 l106 in let i_temp108 = Uint256 108 in let l108 = Cons {Uint256} i_temp108 l107 in let i_temp109 = Uint256 109 in let l109 = Cons {Uint256} i_temp109 l108 in let i_temp110 = Uint256 110 in let l110 = Cons {Uint256} i_temp110 l109 in let i_temp111 = Uint256 111 in let l111 = Cons {Uint256} i_temp111 l110 in let i_temp112 = Uint256 112 in let l112 = Cons {Uint256} i_temp112 l111 in let i_temp113 = Uint256 113 in let l113 = Cons {Uint256} i_temp113 l112 in let i_temp114 = Uint256 114 in let l114 = Cons {Uint256} i_temp114 l113 in let i_temp115 = Uint256 115 in let l115 = Cons {Uint256} i_temp115 l114 in let i_temp116 = Uint256 116 in let l116 = Cons {Uint256} i_temp116 l115 in let i_temp117 = Uint256 117 in let l117 = Cons {Uint256} i_temp117 l116 in let i_temp118 = Uint256 118 in let l118 = Cons {Uint256} i_temp118 l117 in let i_temp119 = Uint256 119 in let l119 = Cons {Uint256} i_temp119 l118 in let i_temp120 = Uint256 120 in let l120 = Cons {Uint256} i_temp120 l119 in let i_temp121 = Uint256 121 in let l121 = Cons {Uint256} i_temp121 l120 in let i_temp122 = Uint256 122 in let l122 = Cons {Uint256} i_temp122 l121 in let i_temp123 = Uint256 123 in let l123 = Cons {Uint256} i_temp123 l122 in let i_temp124 = Uint256 124 in let l124 = Cons {Uint256} i_temp124 l123 in
                let i_temp125 = Uint256 125 in let l125 = Cons {Uint256} i_temp125 l124 in let i_temp126 = Uint256 126 in let l126 = Cons {Uint256} i_temp126 l125 in let i_temp127 = Uint256 127 in let l127 = Cons {Uint256} i_temp127 l126 in
            let folder = fun(cur_res_and_x: ResAndX) => fun(i: Uint256) =>
                match cur_res_and_x with
                | ResAndX local_res local_x =>
                    let new_x = muldiv local_x local_x FIXED_1 in (* now 1 < x < 4 *)
                    let new_x_ge_two = uint256_ge new_x FIXED_2 in
                    match new_x_ge_two with
                    | True =>
                        let shiftedX = builtin div new_x two_uint256 in
                        let one = Uint256 1 in
                        let i_minus_one = builtin sub i one in
                        let two_pow_i_minus_one = builtin pow two_uint256 i_minus_one in
                        let oneShifted = builtin mul one two_pow_i_minus_one in
                        let newRes = builtin add local_res oneShifted in
                        ResAndX newRes shiftedX
                    | False => ResAndX local_res new_x
                    end
                end in
            let fold = @list_foldl Uint256 ResAndX in
            let init = ResAndX res1 x1 in
            let result_res_and_x = fold folder init l127 in
            match result_res_and_x with
            | ResAndX res2 x2 =>
                muldiv res2 LN2_NUMERATOR LN2_DENOMINATOR
            end
        | False => muldiv res1 LN2_NUMERATOR LN2_DENOMINATOR
        end
    end

(* implements both optimal log and general log to provide an abstraction layer for log *)
let log: Uint256 -> Uint256 = 
    fun(base: Uint256) =>
    let can_do_optimal_log = uint256_lt base OPT_LOG_MAX_VAL in
    match can_do_optimal_log with
    | True => optimalLog base
    | False => generalLog base
    end

(* @result is the result of the apply of the power function *)
(* @precision is 2^numberOfBitsOfPrecision *)
type PowerResultAndPrecision =
| PowerResultAndPrecision of Uint256 Uint256

(* this is used as a guard in the power function *)
let panic_if_uint256_not_lt_uint256: Uint256 -> Uint256 -> Bool =
    fun(i1: Uint256) => fun(i2: Uint256) =>
    let is_less_than = uint256_lt i1 i2 in
    let tmp = match is_less_than with | True => zero_uint256 | False => panic zero_uint256 end in
    is_less_than

(*
    General Description:
        Determine a value of precision.
        Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.
        Return the result along with the precision used.

    Detailed Description:
        Instead of calculating "base ^ exp", we calculate "e ^ (log(base) * exp)".
        The value of "log(base)" is represented with an integer slightly smaller than "log(base) * 2 ^ precision".
        The larger "precision" is, the more accurately this value represents the real value.
        However, the larger "precision" is, the more bits are required in order to store this value.
        And the exponentiation function, which takes "x" and calculates "e ^ x", is limited to a maximum exponent (maximum value of "x").
        This maximum exponent depends on the "precision" used, and it is given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".
        Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.
        This allows us to compute "base ^ exp" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.
        This functions assumes that "_expN < 2 ^ 256 / log(MAX_NUM - 1)", otherwise the multiplication should be replaced with a "safeMul".
*)
let power: Uint256 -> Uint256 -> Uint256 -> Uint256 -> PowerResultAndPrecision =
    fun(_baseN: Uint256) => fun(_baseD: Uint256) => fun(_expN: Uint256) => fun(_expD: Uint256) =>
    let is_smaller = panic_if_uint256_not_lt_uint256 _baseN MAX_NUM in
    let base = muldiv _baseN FIXED_1 _baseD in
    let baseLog = log base in
    let baseLogTimesExp = muldiv baseLog _expN _expD in
    
    let baseLogTimesExp_lt_max_val = uint256_lt baseLogTimesExp in
    match baseLogTimesExp_lt_max_val with
    | True =>
        let exp_res = optimalExp baseLotTimesExp in
        PowerResultAndPrecision exp_res MAX_PRECISION 
    | False =>
        let precision = findPositionInMaxExpArray baseLogTimesExp in
        let max_sub_precision = builtin sub MAX_PRECISION precision in
        let two_pow_max_sub_precision = builtin pow two_uint256 max_sub_precision in
        let baseLogTimesExpShifted = builtin div baseLogTimesExp two_pow_max_sub_precision in
        let exp_res = generalExp baseLogTimesExpShifted precision in
        PowerResultAndPrecision exp_res precision
    end

    (* if (baseLogTimesExp < OPT_EXP_MAX_VAL) {
        return (optimalExp(baseLogTimesExp), MAX_PRECISION);
    }
    else {
        uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);
        return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);
    } *)


contract BancorFormula()

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure AssertNotZero(value: Uint256)
    is_zero = builtin eq zero_uint256 value;
    match is_zero with
    | False => 
    | True => e = CodeInputIsZero; ThrowError e
    end
end

procedure AssertIsLE(i1: Uint256, i2: Uint256)
    is_le = uint256_le i1 i2;
    match is_le with
    | False => e = CodeInputNotInBounds; ThrowError e
    | True =>
    end
end

procedure SendCalculatePurchaseReturnCallback(result: Uint128)
    msg = let m = {
        _tag: "CalculatePurchaseReturnCallback";
        _recipient: _sender;
        _amount: zero_uint128;
        result: result
    } in one_msg m;
    send msg
end
(*
    @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),
    calculates the return for a given conversion (in the main token)

    Formula:
    Return = _supply * ((1 + _deposit_amount / _connector_balance) ^ (_connector_weight / 1000000) - 1)

    @param _supply              token total supply
    @param _connector_balance    total connector balance
    @param _connector_weight     connector weight, represented in ppm, 1-1000000
    @param _deposit_amount       deposit amount, in connector token

    @send purchase return amount
    in form:
    {
        _tag: "CalculatePurchaseReturnCallback";
        _recipient: _sender;
        _amount: zero_uint128;
        result: result
    }
*)
transition CalculatePurchaseReturn(_supply: Uint128, _connector_balance: Uint128, _connector_weight: Uint128, _deposit_amount: Uint128)
    (* convert uint128s to uint256s *)
    supply = uint128_to_uint256 _supply;
    connector_balance = uint128_to_uint256 _connector_balance;
    connector_weight = uint128_to_uint256 _connector_weight;
    deposit_amount = uint128_to_uint256 _deposit_amount;
    (* validate input *)
    AssertNotZero supply;
    AssertNotZero connector_balance;
    AssertNotZero connector_weight;
    AssertIsLE connector_weight MAX_WEIGHT;
    deposit_is_zero = builtin eq deposit_amount zero_uint256;
    match deposit_is_zero with
    | True =>
        (* special case for 0 deposit amount *)
        SendCalculatePurchaseReturnCallback zero_uint128
    | False =>
        connector_weight_is_max_weight = builtin eq connector_weight MAX_WEIGHT;
        match connector_weight_is_max_weight with
        | True =>
            (* special case if the weight = 100% *)
            supply_mul_deposit = builtin mul supply deposit_amount;
            result_uint256 = builtin div supply_mul_deposit connector_balance;
            result = uint256_to_uint128 result_uint256;
            SendCalculatePurchaseReturnCallback result
        | False =>
            baseN = builtin add deposit_amount connector_balance;
            power_result_and_precision = power baseN connector_balance connector_weight MAX_WEIGHT;
            match power_result_and_precision with
            | PowerResultAndPrecision power_result precision =>
                supply_mul_power_result = builtin mul supply power_result;
                tmp = builtin div supply_mul_power_result precision;
                result_uint256 = builtin sub tmp supply;
                result = uint256_to_uint128 result_uint256;
                SendCalculatePurchaseReturnCallback result
            end
        end
    end
end